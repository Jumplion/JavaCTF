Project Members:
	Tomer Braff

Agent Description and Analysis

txb130030Agent utilizes several concepts learned over the course of the AI class. First, because there were some problems when I attempted to include an argumentless constructor for the Agent, each Agent as an "initialized" boolean that, if false, will go to the "Initialize" function at the beginning of the first step. This initialization involves determining if the Agent has spawned in the top left, top right, bottom left, or bottom right corner of the map by looking at the environment around it and what direction both its team base and the enemy base are at. Initializing also specifies if the Agent will be a defender or not, which just means that one Agent will run after the enemy flag, while the other will hover around their team base. If the enemy has the team flag, the defender will make a beeline for the enemy base in an effort to catch them.

Also in the Initialize here is where the static map of the arena is created (if it wasn't already created by another Agent being initialized). This map is accessible to all txb130030Agents. Each step the txb130030Agent takes note of its surrounding as updates the map accordingly. An Agent can look north, south, east, and west from its current node position and assign those tiles an ObsType (obstacle type) like Obstacle, Foe, or None. These ObsTypes will help determine where the Agent should go next.

After the Agent has updated their surroundings, they then search for a path using the A* pathfinding algorithm from their current position to either the enemy base or their own base depending on if they have the flag or not. The enemy base is assumed to be at (9,4) relative to their own base at (0,4), and because of that the agents only really work on 10x10 arenas, but I'm okay with that because. If the Agent finds a safe path to the enemy/team base (one not obstructed by obstacles or enemies) then the Agent will go in the direction at the start of that path. If, however, the Agent does not find a path, they will instead clear the static map as something as gone wrong. I couldn't figure out a solution to this as the Agents would sometimes mark a tile as obstructed when there wasn't anything there, probably as a mistake regarding an enemy or how AgentEnvironment returns what is an obstacle and what isn't.

There are multiple functions and features in this code implementation, mostly a huge mess to look at, but it does help me streamline some code calls. For example, instead of constantly calling "CheckObstacleNorth/South/East/West" four times in a row, I instead made a single function to encapsulate all those smaller, specific functions, and passed an integer {0, 1, 2, 3} to specify the North, South, East, and West direction. Also in some functions, like "CheckAgentAdjacent", I implemented a simple boolean argument to specify if I wanted to check for a Friendly agent or an Enemy agent adjacent at the specified NSEW direction. In hindesight, this was probably overkill and/or needlessly complicating the code just because I didn't want to rewrite some code, though it was more helpful in the CheckAgentAdjacent function since I could specify a specific enemy type.

Overall, the project was interesting, challenging but not too challenging (at least until I gave up trying to do more general cases and just forced it to do 10x10 arenas).